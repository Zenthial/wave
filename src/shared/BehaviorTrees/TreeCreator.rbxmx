<roblox version="4">
  <Item class="ModuleScript" referent="0">
    <Properties>
      <string name="Name">TreeCreator</string>
      <BinaryString name="AttributesSerialize">
      </BinaryString>
      <Content name="LinkedSource">
        <null>
        </null>
      </Content>
      <BinaryString name="ScriptGuid"><![CDATA[ezE5NzlCNUU3LUE3QjMtNEM4RS1BQjk5LUEzMENDMDQwQzA2QX0=]]></BinaryString>
      <string name="Source">local TreeCreator = {};

local TreesFolder = script.Parent.Trees;

local BehaviorTree2 = require(script.BehaviorTree2);

-- March 17 2020.
-- Added support for Weight and Linked Duplicates, fixed weight bug-

function TreeCreator:Create(obj,treeindex)
	if not obj or not treeindex then
		warn("Invalid parameters, expecting object,treeindex");
		return;
	end
	local Tree = self:_getTree(treeindex);
	if Tree then
		Tree = Tree:clone();
		Tree:setObject(obj);
		return Tree;
	else
		warn("Couldn't get tree for ",treeindex);
	end
end

local Trees = {};

local SourceTasks = {};

local function GetModule(ModuleScript)
	local found = SourceTasks[ModuleScript];
	if found then
		return found;
	else
		found = require(ModuleScript);
		SourceTasks[ModuleScript]=found;
		return found;
	end
end
local function GetModuleScript(folder)
	local found = folder:FindFirstChildWhichIsA("ModuleScript");
	if found then
		return found;
	else
		local link = folder:FindFirstChild("Link");
		if link then
			local linked = link.Value;
			if linked then
				return GetModuleScript(linked);
			end
		end
	end
end
function TreeCreator:_getSourceTask(folder)
	local ModuleScript = GetModuleScript(folder);
	if ModuleScript then
		return GetModule(ModuleScript);
	end
end
function TreeCreator:_buildNode(folder)
	local nodeType = folder.Type.Value;
	
	local weight = folder:FindFirstChild("Weight") and folder.Weight.Value or 1;
		
	if nodeType == "Invert" then
		nodeType="InvertDecorator";
	elseif nodeType == "Fail" then
		nodeType="AlwaysFailDecorator"
	elseif nodeType == "Succeed" then
		nodeType="AlwaysSucceedDecorator";
	end
	
	local Decorator;
	if nodeType:match("Decorator") then
		Decorator=true;
	end
	
	local node;
	
	if nodeType == "Task" then
		local sourcetask = self:_getSourceTask(folder) or {};
		node = BehaviorTree2.Task:new(sourcetask);
		node.weight=weight;
	else
		local Outputs = folder.Outputs:GetChildren();
		local orderedChildren = {};
		for i = 1,#Outputs do
			local objvalue = Outputs[i];
			table.insert(orderedChildren,objvalue);
		end
		table.sort(orderedChildren,function(a,b)
			return tonumber(a.Name) &lt; tonumber(b.Name);
		end)
		for i = 1,#orderedChildren do
			orderedChildren[i] = self:_buildNode(orderedChildren[i].Value);
		end
		if Decorator then
			node = BehaviorTree2[nodeType]:new({node=orderedChildren[1]});
			node.weight=weight;
		else
			node = BehaviorTree2[nodeType]:new({nodes=orderedChildren});
			node.weight=weight;			
		end
	end	
	return node;
end
function TreeCreator:_createTree(treeindex)
	local treeFolder = TreesFolder:FindFirstChild(treeindex);
	if not treeFolder then
		warn(string.format("Could not find tree %s under BehaviorTrees.Trees!"),treeindex);
		return;
	end
	local nodes = treeFolder.Nodes;
	local RootFolder = nodes:FindFirstChild("Root");
	if not RootFolder then
		warn(string.format("Could not find Root under BehaviorTrees.Trees.%s.Nodes!"),treeindex);
		return;
	end
	
	if #RootFolder.Outputs:GetChildren() == 0 then
		warn(string.format("The root node has no outputs connected for %s!",treeindex));
		return;	
	end
	
	local root = self:_buildNode(RootFolder);
	
	local Tree = BehaviorTree2:new({tree=root});
	return Tree;	
end
function TreeCreator:_getTree(treeindex)
	return Trees[treeindex] or self:_createTree(treeindex);
end

return TreeCreator;</string>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">BehaviorTree2</string>
        <BinaryString name="AttributesSerialize">
        </BinaryString>
        <Content name="LinkedSource">
          <null>
          </null>
        </Content>
        <BinaryString name="ScriptGuid"><![CDATA[ezEzMTkwQzdDLTIxMjctNDZFQS1BQzUxLUI3ODhEMURGMTY4Qn0=]]></BinaryString>
        <string name="Source">local BehaviorTree = {} do
    
	local function ProcessNode(node, nodes)
		if node.type == "task" then
			local task = {
				type = "task",
				status = nil,
				
				start = node.params.start,
				run = node.params.run,
				finish = node.params.finish,
				
				onsuccess = true,
				onfail = false
			}

			--decorators
			if node.params.decorator ~= nil then
				if node.params.decorator == "always_succeed" then
					task.task = {
						running = function(self) task.status = "running" end,
						success = function(self) task.status = "success" end,
						fail = function(self) task.status = "success" end
					}
				
				elseif node.params.decorator == "always_fail" then
					task.task = {
						running = function(self) task.status = "running" end,
						success = function(self) task.status = "fail" end,
						fail = function(self) task.status = "fail" end
					}

				elseif node.params.decorator == "invert" then
					task.task = {
						running = function(self) task.status = "running" end,
						success = function(self) task.status = "fail" end,
						fail = function(self) task.status = "success" end
					}

				end
			else
				task.task = {
					running = function(self) task.status = "running" end,
					success = function(self) task.status = "success" end,
					fail = function(self) task.status = "fail" end
				}
			end
			
			nodes[#nodes + 1] = task


		elseif node.type == "decorator" then

			node.params.node.params.decorator = node.params.decorator
			ProcessNode(node.params.node, nodes)

		elseif node.type == "sequence" then
			-- child.success = final ? parent.success : parent.next
			-- child.fail = parent.fail (default)
				
			for i,childNode in pairs(node.params.nodes) do
				local final = i == #node.params.nodes
				local start = #nodes + 1
				
				ProcessNode(childNode, nodes)
				
				for i = start, #nodes do
					local node = nodes[i]
					
					-- on child.success, !final ? parent.next : parent.success
					if node.onsuccess == true then
						node.onsuccess = not final and #nodes + 1 or true
					end
					
					if node.onfail == true then
						node.onfail = not final and #nodes + 1 or true
					end
				end
			end
		elseif node.type == "priority" then
			-- child.success = parent.success (default)
			-- child.fail = final ? parent.fail : parent.next
			
			for i,childNode in pairs(node.params.nodes) do
				local final = i == #node.params.nodes
				local start = #nodes + 1
				
				ProcessNode(childNode, nodes)
				
				for i = start, #nodes do
					local node = nodes[i]
					
					-- on child.fail, !final ? parent.next : parent.fail
					if node.onsuccess == false then
						node.onsuccess = not final and #nodes + 1 or false
					end
					
					if node.onfail == false then
						node.onfail = not final and #nodes + 1 or false
					end
				end
			end
		elseif node.type == "random" then
			-- child.success = parent.success (default)
			-- child.fail = parent.fail (default)
			
			local random = {
				type = "random",
				indices = {}
			}
			
			nodes[#nodes + 1] = random
			
			for _,childNode in pairs(node.params.nodes) do
				if childNode.weight then
					-- childNode.weight = math.clamp(childNode.weight, 1, 200)
					local base = #random.indices;
					local index = #nodes + 1

					for i = 1, childNode.weight do
						random.indices[base + i] = index
					end
				else
					random.indices[#random.indices + 1] = #nodes + 1
				end

				ProcessNode(childNode, nodes)
			end
		elseif node.type == "tree" then
			local start = #nodes + 1
			
			ProcessNode(node.tree, nodes)
			
			for i = start, #nodes do
				local node = nodes[i]
				
				if node.onsuccess == true or node.onsuccess == false then
					node.onsuccess = #nodes + 1
				end
				
				if node.onfail == true or node.onfail == false then
					node.onfail = #nodes + 1
				end
			end
		else
			error("ProcessNode: bad node.type " .. tostring(node.type))
		end
	end
	
	
	
	local TreeProto = {}
	
	function TreeProto:run(dt)
		if self.running then
			-- warn(debug.traceback("Tried to run BehaviorTree while it was already running"))
			return
		end
		
		local nodes = self.nodes
		local obj = self.object
		local i = self.index
		local nodeCount = #nodes
		
		local didResume = self.paused
		self.paused = false
		self.running = true
	
		while i &lt;= nodeCount do
			local node = nodes[i]
			
			if node.type == "task" then
				local task = node.task
				
				if didResume then
					didResume = false
				elseif node.start then
					node.start(task, obj, dt)
				end
				
				node.status = nil
				node.run(task, obj, dt)
				
				if not node.status then
					warn("node.run did not call success, running or fail, acting as fail")
					node.status = "fail"
				end
				
				if node.status == "running" then
					self.paused = true
					break
				elseif node.status == "success" then
					if node.finish then
						node.finish(task, obj, dt)
					end
					
					i = node.onsuccess
				elseif node.status == "fail" then
					if node.finish then
						node.finish(task, obj, dt)
					end
					
					i = node.onfail
				else
					error("bad node.status")
				end
			elseif node.type == "random" then
				i = node.indices[math.random(1, #node.indices)]
			else
				error("bad node.type")
			end
		end
		
		self.index = i &lt;= nodeCount and i or 1
		self.running = false
	end
			
	function TreeProto:setObject(object)
	 	self.object = object
	end
	
	function TreeProto:clone()
		return setmetatable({
			nodes = self.nodes,
			index = self.index,
			object = self.object
		}, { __index = TreeProto })
	end
	
	
	
	function BehaviorTree:new(params)
		local tree = params.tree
		local nodes = {}
		
		ProcessNode({ type = "tree", tree = tree }, nodes)
		
		return setmetatable({
			nodes = nodes,
			index = 1,
			object = nil
		}, { __index = TreeProto })
	end
	
	BehaviorTree.Task = {
		new = function(_, params)
			return {
				type = "task",
				params = params
			}
		end
	}
	
	BehaviorTree.Sequence = {
		new = function(_, params)
			return {
				type = "sequence",
				params = params
			}
		end
	}
	
	BehaviorTree.Priority = {
		new = function(_, params)
			return {
				type = "priority",
				params = params
			}
		end
	}
	
	BehaviorTree.Random = {
		new = function(_, params)
			return {
				type = "random",
				params = params
			}
		end
	}

	--Decorators
	BehaviorTree.AlwaysSucceedDecorator = {
		new = function(_, params)
			params.decorator = "always_succeed"
			return {
				type = "decorator",
				params = params
			}
		end
	}

	BehaviorTree.AlwaysFailDecorator = {
		new = function(_, params)
			params.decorator = "always_fail"
			return {
				type = "decorator",
				params = params
			}
		end
	}

	BehaviorTree.InvertDecorator = {
		new = function(_, params)
			params.decorator = "invert"
			return {
				type = "decorator",
				params = params
			}
		end
	}
end

return BehaviorTree</string>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
  </Item>
</roblox>